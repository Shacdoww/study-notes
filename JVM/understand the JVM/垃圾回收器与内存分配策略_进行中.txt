对象的创建

创建这里需要思考两个问题
-空间的划分
-线程安全

-空间的划分

执行new 指令时首先去常量池中寻找是否能定位到一个类的符号, 并且检查这个符号引用的类是否被加载解析和初始化
如果没有必须先执行相应类的加载过程

开始给创建的对象在heap中划分内存这个过程等于在堆中划分一块空闲的空间(这个空间的大小在类加载完成后就可以确定)

这里分为两种情况
1. 如果假设Java堆中的内存是规整的, 也就是说用过的内存在一侧, 没用过的内存在另一侧, 中间有一个指针作为分界点
   指示器, 给新的对象分配内存时只需要移动指针位置, 这种方式被称为指针碰撞(Bump the Pointer)

2. 另一种情况与上面相反heap中的内存是使用和未使用过的纵横交错, VM必须来维护一个列表上面记录了heap的使用情况, 
   从上面分配一块足够的空间给新的对象实例, 并且对表进行维护, 这种方式被称为空闲列表(Free List)

至于heap中的内存是否规整, 则取决于使用了垃圾回收器是否带有内存压缩整理功能, 所以在使用 Serial, ParNew 算法的
收集器时 系统采用指针碰撞, 而在采用CMS这种基于Mark-Sweep算法的收集器则通常使用 Free List.

-线程安全

创建对象在VM中是一个非常频繁的过程, 即使是移动指针这种简单的操作在高并发下也并非是一个安全的操作, 比如 在给
对象A分配空间移动指针时, 恰好对象B分配空间, 此时指针还未来得及移动, 则会在原来没有给A划分内存的基础上给B划分
内存.

两种解决方案
1. 对分配内存空间的动作进行一个同步处理, VM使用CAS + 失败重试的方式实现 并且保证原子性
2. 把内存分配的动作划分到不同的空间进行, 采用TLAB哪个线程需要分配空间就在哪个线程的TLAB上执行, 只在TLAB耗尽时
   进行同步锁重新分配TLAB空间, VM是否使用TLAB 可以通过-XX:+/-UseTLAB参数来设定.

内存分配完成, VM会将对应的空间初始化为0(不包括对象头), 如果采用TLAB 可以在TLAB分配时完成初始, 这一步就保证了
程序在访问相应字段的时候可以得到对应数据类型的0值.

VM对类进行必要设置
VM 看来新对象已经产生, 程序认为刚开始, 是否需要init方法则根据相应参数

对象内存布局
对象头 
实例数据
内存填充

对象访问定位
句柄
指针



GC

人们在思考GC需要完成的3件事
1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

叙述:
	程序计数器, 虚拟机栈, 本地方法栈, 这3个区域 的生命周期和线程相同, 栈中的帧栈随着程序的进行
	有序的的入栈出栈, 每个帧栈分配多少内存基本上在类结构确定下来的时候就可以基本上确认了(虽然JIT
	会进行一些结构优化, 但基本上认为已知), 因此这几个区域的内存情况是比较清晰的, 内存的分配和回收
	具有确定性, 因为放假结束或者线程结束的时候内存就会被回收. 而Java heap 和 Method Area则不同,
	一个接口中的多个实现类可能所需要的内存不同, 一个方法的多个分支所需要的内存也可能存在不同, 这
	部分内存的分配和回收都是动态的, 也是GC最为关注的部分.

GC 算法

引用计数算法
	优点: 实现简单, 判断效率高, 大部分情况下是一个比较适用的算法.
	缺点: 很难解决对象之间的循环引用问题

可达性分析算法
	描述: 通过可达性分析, 进行GC 商用VM的主流用法
	GC Roots

引用
Java在1.2之前, 引用定义的很传统, 如果reference类型的数据中存储的数值代表另外一块内存空间的起始地址,
就称为引用, 这种方式虽然很纯粹但是有些过于狭隘, 描述情况也太过绝对, 只有被引用和没被引用两种状态.
我们希望能描述这样一些对象, 在内存空间足够的时候保留, 在内存紧张时候则抛弃, 在JDK1.2之后对引用的概念
进行了扩充, 分为 强 软 弱 虚 

不可达算法 finalize() 方法 和两次标记

回收 Method Area