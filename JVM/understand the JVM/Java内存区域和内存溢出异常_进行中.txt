对象的创建

创建这里需要思考两个问题
-空间的划分
-线程安全

-空间的划分

执行new 指令时首先去常量池中寻找是否能定位到一个类的符号, 并且检查这个符号引用的类是否被加载解析和初始化
如果没有必须先执行相应类的加载过程

开始给创建的对象在heap中划分内存这个过程等于在堆中划分一块空闲的空间(这个空间的大小在类加载完成后就可以确定)

这里分为两种情况
1. 如果假设Java堆中的内存是规整的, 也就是说用过的内存在一侧, 没用过的内存在另一侧, 中间有一个指针作为分界点
   指示器, 给新的对象分配内存时只需要移动指针位置, 这种方式被称为指针碰撞(Bump the Pointer)

2. 另一种情况与上面相反heap中的内存是使用和未使用过的纵横交错, VM必须来维护一个列表上面记录了heap的使用情况, 
   从上面分配一块足够的空间给新的对象实例, 并且对表进行维护, 这种方式被称为空闲列表(Free List)

至于heap中的内存是否规整, 则取决于使用了垃圾回收器是否带有内存压缩整理功能, 所以在使用 Serial, ParNew 算法的
收集器时 系统采用指针碰撞, 而在采用CMS这种基于Mark-Sweep算法的收集器则通常使用 Free List.

-线程安全

创建对象在VM中是一个非常频繁的过程, 即使是移动指针这种简单的操作在高并发下也并非是一个安全的操作, 比如 在给
对象A分配空间移动指针时, 恰好对象B分配空间, 此时指针还未来得及移动, 则会在原来没有给A划分内存的基础上给B划分
内存.

两种解决方案
1. 对分配内存空间的动作进行一个同步处理, VM使用CAS + 失败重试的方式实现 并且保证原子性
2. 把内存分配的动作划分到不同的空间进行, 采用TLAB哪个线程需要分配空间就在哪个线程的TLAB上执行, 只在TLAB耗尽时
   进行同步锁重新分配TLAB空间, VM是否使用TLAB 可以通过-XX:+/-UseTLAB参数来设定.

内存分配完成, VM会将对应的空间初始化为0(不包括对象头), 如果采用TLAB 可以在TLAB分配时完成初始, 这一步就保证了
程序在访问相应字段的时候可以得到对应数据类型的0值.

VM对类进行必要设置
VM 看来新对象已经产生, 程序认为刚开始, 是否需要init方法则根据相应参数

对象内存布局
对象头 
实例数据
内存填充

对象访问定位
句柄
指针



