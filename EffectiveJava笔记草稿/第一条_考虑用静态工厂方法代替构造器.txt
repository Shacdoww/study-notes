描述: 静态工厂方法, 这里并不是指设计模式中的工厂方法. 而是通过公有的静态工厂方法来获取类的实例.

静态工厂方法与构造器的比较

优势
1. 它们拥有独立的名称.

	. 更易于理解, 尤其是在构造器的参数并不能确切的表述返回的类时.
	. 当需要多个相同签名的构造器方法时可以使用工厂方法, 慎重命名以示区别.

	PS: 
		.方法签名: 从左至右包括方法名、参数类型和个数
		.可用通过调整参数的顺序来实现相同签名的构造器, 但是这样的代码不利于了解阅读

2. 不必在每次调用它们的时候创建新的对象

	.避免创建不必要的重复对象, 不可变类可以使用预先构建好的实例(15条), 也可在重复创建相同的对象成本高昂时使用
	.可用于实例受控的类

	PS：为什么要创建实例受控的类

3. 可以返回原返回类的任何子类型的对象 
	
	.选择返回对象的类时有了更大的灵活性
		一种应用方式是.API可以返回对象, 同时又不会使类变成公有的. 这种隐藏方式会使API变得更加简洁.
		适用于基于接口的框架  这种框架接口为工厂方法提供了自然的返回类型Type 接口不能有静态方法 所以按照惯例
		会有一个Type的静态工厂类types 的不可实例化的类
		↑ 应用举例 Java Collection Framework 的集合接口有32个便利的实现 这些实例几乎都可以在一个不可实例化的 静态工厂方法类 Collections中导出
		 例子分析 1. api的减少 2. 1的基础上意味着概念的减少 因为是由相关类精确指定 几乎可以不用阅读文档 3. 这样甚至要求用接口引用返回的实例 一个良好的习惯

	.提升可维护性和性能
		返回的类可以是 非公有
		可以随着每次调用改变返回实例 也取决于调用的参数
		允许返回任何返回类型的子类型
		可以随着版本 可以增删返回的实例 可以随着发行版本改变返回实例

	例子 java.util.EnumSet 
		 没有公有构造器 只有静态工厂方法
		 返回两种实 取决于底层枚举类型的大小 来采用不同的实现用以提升效率
		 实现类对于客户端来说都是不可见的 可以对实现类进行增删 
		 客户端只需要知道是EnumSet的某个子类即可
	.


http://ask.csdn.net/questions/261205 
http://liwenshui322.iteye.com/blog/1267202
